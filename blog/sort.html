<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Sorting Algorithms</title>
<meta charset="UTF-8"/>
<meta name="author" content="Christopher H. Harvey"/>
<meta name="description" content="A comparison of the most popular comparison sorting algorithms used in computer science."/>
<meta name="keywords" content="computer science, sorting, algorithm"/>
<link rel="stylesheet" href="../bower_components/normalize.css/normalize.css"/>
<link rel="stylesheet" href="../bower_components/xmeter/xmeter.css"/>
<link rel="stylesheet" href="../core/styles/project.css"/>
</head>
<body>
<main class="MainGolden Article Article--draft" data-status="draft" itemscope="" itemtype="https://schema.org/Article">
<header>
  <h1 itemprop="name headline">Comparison Sorting Algorithms</h1>
  <dl class="Docmeta">
    <dt>Author</dt>
    <dd itemprop="author">Christopher H. Harvey</dd>
    <dt>Description</dt>
    <dd itemprop="description">A comparison of the most popular comparison sorting algorithms used in computer science.</dd>
    <dt>Keywords</dt>
    <dd itemprop="keywords">computer science</dd>
    <dd itemprop="keywords">sorting</dd>
    <dd itemprop="keywords">algorithm</dd>
    <dt>Version History</dt>
    <dd class="update" itemprop="dateModified"><time datetime="2014-10-16 21:14">Oct 16, 2014 <span class="hm">21:14 PM</span></time></dd>
  </dl>
</header>
<p class="p--Lede">This article describes and makes comparisons among the Comparison Sorting Algorithms.</p>
<p>A sorting algorithm takes an unordered list of objects and arranges them according to
  a few axioms of total order. The total ordering relation will be named, for simplicity,
  <i>less-than</i>. The axioms are explained below:</p>
<ul>
  <li>
    <span class="p__Title">Reflexivity</span>
    Any element is <i>less-than</i> itself.
    <figure><span class="M">x\le x</span></figure>
  </li>
  <li>
    <span class="p__Title">Antisymmetry</span>
    Any two elements that are <i>less-than</i> each other are equal.
    <figure>if <span class="M">x\le y</span> and <span class="M">y\le x</span> then
      <span class="M">x=y</span></span></figure>
  </li>
  <li>
    <span class="p__Title">Transitivity</span>
    The <i>less-than</i> relation carries over.
    <figure>if <span class="M">x\le y</span> and <span class="M">y\le z</span> then
      <span class="M">x\le z</span></figure>
  </li>
  <li>
    <span class="p__Title">Totality</span>
    Any two elements can be compared to each other.
    <figure><span class="M">x\le y</span> or <span class="M">y\le x</span> (or possibly both)</figure>
  </li>
</ul>
<p>It is fortunate that these axioms are satisfied by the JavaScript relation
  <code>&lt;=</code> on the positive integers.</p>
<p>In addition to the axioms of total order, we are assuming the set has a finite number
  of elements. It is then a consequence that there be a minimum and a maximum in the set.</p>
<ul>
  <li>
    A <dfn id="d-minimum">minimal element</dfn>, or minimum, in a set is an element that is
    <i>less-than</i> every element in the set.
    <p>there exists an element <span class="M">a</span> in the set such that
      for every <span class="M">x</span> in the set, <span class="M">a \le x</span></p>
  </li>
  <li>
    A <dfn id="d-maximum">maximal element</dfn>, or maximum, in a set is an element for which every
    element is <i>less-than</i> that element.
    <p>there exists an element <span class="M">b</span> in the set such that
      for every <span class="M">x</span> in the set, <span class="M">x \le b</span></p>
  </li>
</ul>
<p>A comparison sorting algorithm sorts a set only by comparing elements in the set,
  as opposed to other sorting algorithms that use other methods... In this article we assume the
  goal is to sort a finite set of positive integers from least to greatest.</p>
<section id="simple">
  <h2>Simple Sorts</h2>
  <section>
    <h3>Selection Sort</h3>
    <p>A <dfn id="d-selection">selection sort</dfn> finds the minimum in the set of all data,
      and then swaps that minimum with the first element. It then repeats this process with the
      remaining data.</p>
    <pre>
function selectSort(dataset) {
  for (var i = 0; i < dataset.length; i++) {
    var subarray = subarray(dataset, i, dataset.length - 1);
    var min = findmin(subarray);
    swap(dataset[i], min);
  }
  return dataset;
}</pre>
    <p>A selection sort has the advantage of executing a maximum of <var>n</var> swaps.</p>
  </section>
  <section>
    <h3>Insertion Sort</h3>
    <!-- <p>An <dfn id="d-insertion">insertion sort</dfn> creates an empty copy of the given array</p> -->
    <h2></h2>
  </section>
</section>
<section id="efficient">
  <h2>Efficient Sorts</h2>
  <section>
    <h3>Mergesort</h3>
  </section>
  <section>
    <h3>Heapsort</h3>
  </section>
  <section>
    <h3>Quicksort</h3>
  </section>
</section>
<section id="bubble-type">
  <h2>Bubble-type Sorts</h2>
  <section>
    <h3>Bubble Sort</h3>
  </section>
  <section>
    <h3>Shell Sort</h3>
  </section>
  <section>
    <h3>Comb Sort</h3>
  </section>
</section>
<table class="Table">
  <caption>comparison of Comparison Sorts</caption>
  <thead class="Rowgroup Head">
    <tr class="Row">
      <th class="Cell Hc">Name</th>
      <th class="Cell Hc">Runtime Range</th>
      <th class="Cell Hc">Swaps Range</th>
    </tr>
  </thead>
  <tbody class="Rowgroup Body">
    <tr class="Row">
      <th class="Cell Hc">Selection</th>
      <td class="Cell">O(n^2)</td>
      <td class="Cell">0&ndash;O(n)</td>
    </tr>
    <tr class="Row">
      <th class="Cell Hc">Insertion</th>
      <td class="Cell">O(n)&ndash;O(n^2)</td>
      <td class="Cell">O(n)</td>
    </tr>
  </tbody>
</table>
</main>
<script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,https://chharvey.github.io/hosting/mathjax-localconfig.js"></script>
<script src="../core/scripts/global.js"></script>
<script src="sort.js"></script>
</body>
</html>
